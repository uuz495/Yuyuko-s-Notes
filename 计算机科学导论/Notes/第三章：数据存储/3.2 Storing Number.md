
## **3.2.1 Storing Integers**

### ✅ What is an Integer?

An **integer** is a whole number — it has **no decimal or fraction**.
Examples:

*  `134`, `-125` are integers
*  `134.23`, `-0.235` are **not** integers

To store integers, computers use a method called **fixed-point representation**.

> 📌 This means the **decimal point is fixed** (assumed to be at the right) and **not actually stored**.

---

### ✅ **Unsigned Integers**

An **unsigned integer** is a number that can only be **0 or positive**.
It **cannot** be negative.

#### 📌 Memory Limitation

If a computer uses **n bits**, the maximum unsigned integer is:

> **2ⁿ − 1**

Example:

* If **n = 4 → max number = 2⁴ − 1 = 15**

---

### ✅ What is Overflow?

**Overflow** happens when a number is **too big** to fit in the available bits.

#### Example:

If you try to store the number **20** in **4 bits**:

* 20 in binary = `10100` (needs 5 bits!)
* If only 4 bits are allowed, computer keeps last 4 bits → `0100`
* `0100` in decimal = **4** 

---

### ✅ Why Use Unsigned Integers?

Because:

* You don’t need to store the sign **(no negative numbers)**
* You can use **all bits** for the number → **more efficient**

#### Example Uses:

* **Counting** (e.g., number of people)
* **Memory addresses** (locations are never negative)
* **Storing data** like images, audio, and text — just patterns of bits

---

### ✅ How to Store Unsigned Integers (Steps)

1. Convert the integer to **binary**
2. If it needs **fewer than n bits**, add `0`s on the **left**
3. If it needs **more than n bits**, it **can’t be stored** — this is **overflow**

#### Example 3.1: Store 7 in 8 bits

* 7 in binary = `111`
* Add 5 zeros → `00000111`

#### Example 3.2: Store 258 in 16 bits

* 258 in binary = `100000010`
* Add 7 zeros → `0000000100000010`

---

### ✅ Retrieving Unsigned Integers

To **get a number back** from memory:

* The output device reads the **bit string**
* Then **converts it** to a decimal number

#### Example 3.3:

Bit string in memory = `00101011`

* Convert to decimal = **43**

---

## ✅ Sign-and-Magnitude Representation

### 📌 What is it?

Sign-and-magnitude is a way to store integers where:

* The **leftmost bit** represents the **sign**:

  * `0` for positive
  * `1` for negative
* The **remaining bits** store the **magnitude** (i.e., the absolute value).

---

### ✅ Key Characteristics:

* For an `n`-bit value, the **range** is:

  **$$
  -(2^{n-1} - 1) \text{ to } + (2^{n-1} - 1)
  $$**
* There are **two zeros**: positive zero (e.g. `0000`) and negative zero (e.g. `1000`)
* It’s **not commonly used** for integers, but it **is used**:

  * To store the **sign** part of **floating-point numbers**
  * In **analog signal quantization**, such as **audio**

---

### 📌 Examples:

#### 🧾 Example 3.4: Store `+28` in 8-bit memory

1. Convert `28` to 7-bit binary → `0011100`
2. Add sign bit `0` at the front → `00011100`

#### 🧾 Example 3.5: Store `-28` in 8-bit memory

1. Binary of `28` → `0011100`
2. Add sign bit `1` → `10011100`

#### 🧾 Example 3.6: Interpret `01001101`

* Leftmost bit = `0` → positive
* Remaining bits `1001101` = decimal `77`
* So, the number is `+77`

#### 🧾 Example 3.7: Interpret `10100001`

* Leftmost bit = `1` → negative
* Remaining bits `0100001` = decimal `33`
* So, the number is `-33`

---

## ✅ Overflow in Sign-and-Magnitude

### 📌 Positive Overflow:

* Example: `5 + 6 = 11`
* But in 4 bits, max is `+7`, so the result wraps around to `-3`

### 📌 Negative Overflow:

* Example: `-5 - 7 = -12`
* But min is `-7`, so it wraps to `+6`

### ✅ Why?

* The representation is like a **circular ring** — if you exceed the limit, the number “wraps” around from one side to the other.

@import "Negative overflow.png" 

@import "Positive overflow.png"

---

## ✅ Applications:

* **Not used** for storing regular integers due to:

  * Duplicate zero values
  * Complicated arithmetic
* **Used in**:

  * Floating-point number representation (for the **sign bit**)
  * **Analog-to-digital conversion**, like **audio encoding**

---

