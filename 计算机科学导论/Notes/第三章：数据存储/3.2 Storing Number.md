
## **3.2.1 Storing Integers**

### âœ… What is an Integer?

An **integer** is a whole number â€” it has **no decimal or fraction**.
Examples:

*  `134`, `-125` are integers
*  `134.23`, `-0.235` are **not** integers

To store integers, computers use a method called **fixed-point representation**.

> ğŸ“Œ This means the **decimal point is fixed** (assumed to be at the right) and **not actually stored**.

---

### âœ… **Unsigned Integers**

An **unsigned integer** is a number that can only be **0 or positive**.
It **cannot** be negative.

#### ğŸ“Œ Memory Limitation

If a computer uses **n bits**, the maximum unsigned integer is:

> **$2^n -1 $**

Example:

 **$$\text{if} \ n = 4 \rightarrow \text{max number} = 2^4 âˆ’ 1 = 15$$**

---

### âœ… What is Overflow?

**Overflow** happens when a number is **too big** to fit in the available bits.

#### Example:

If you try to store the number **20** in **4 bits**:

* 20 in binary = `10100` (needs 5 bits!)
* If only 4 bits are allowed, computer keeps last 4 bits â†’ `0100`
* `0100` in decimal = **4** 

---

### âœ… Why Use Unsigned Integers?

Because:

* You donâ€™t need to store the sign **(no negative numbers)**
* You can use **all bits** for the number â†’ **more efficient**

#### Example Uses:

* **Counting** (e.g., number of people)
* **Memory addresses** (locations are never negative)
* **Storing data** like images, audio, and text â€” just patterns of bits

---

### âœ… How to Store Unsigned Integers (Steps)

1. Convert the integer to **binary**
2. If it needs **fewer than n bits**, add `0`s on the **left**
3. If it needs **more than n bits**, it **canâ€™t be stored** â€” this is **overflow**

#### Example 3.1: Store 7 in 8 bits

* 7 in binary = `111`
* Add 5 zeros â†’ `00000111`

#### Example 3.2: Store 258 in 16 bits

* 258 in binary = `100000010`
* Add 7 zeros â†’ `0000000100000010`

---

### âœ… Retrieving Unsigned Integers

To **get a number back** from memory:

* The output device reads the **bit string**
* Then **converts it** to a decimal number

#### Example 3.3:

Bit string in memory = `00101011`

* Convert to decimal = **43**

---

## âœ… Sign-and-Magnitude Representation

### ğŸ“Œ What is it?

Sign-and-magnitude is a way to store integers where:

* The **leftmost bit** represents the **sign**:

  * `0` for positive
  * `1` for negative
* The **remaining bits** store the **magnitude** (i.e., the absolute value).

---

### âœ… Key Characteristics:

* For an **$n-bit$** value, the **range** is:

  **$$
  -(2^{n-1} - 1) \text{ to } + (2^{n-1} - 1)
  $$**
* There are **two zeros**: positive zero (e.g. `0000`) and negative zero (e.g. `1000`)
* Itâ€™s **not commonly used** for integers, but it **is used**:

  * To store the **sign** part of **floating-point numbers**
  * In **analog signal quantization**, such as **audio**

---

### ğŸ“Œ Examples:

#### ğŸ§¾ Example 3.4: Store `+28` in 8-bit memory

1. Convert **$28$** to 7-bit binary â†’ **$0011100$**
2. Add sign bit **$0$** at the front â†’ **$00011100$**

#### ğŸ§¾ Example 3.5: Store `-28` in 8-bit memory

1. Binary of **$28 â†’ 0011100$**
2. Add sign bit **$1 \rightarrow 10011100 $**

#### ğŸ§¾ Example 3.6: Interpret `01001101`

* Leftmost bit = **$0 â†’ positive$**
* Remaining bits **$1001101 = 77$**
* So, the number is **$+77$**

#### ğŸ§¾ Example 3.7: Interpret `10100001`

* Leftmost bit = **$1 â†’ negative$**
* Remaining bits **$0100001 =33$**
* So, the number is =**$\space -33$**

---

## âœ… Overflow in Sign-and-Magnitude

### ğŸ“Œ Positive Overflow:

* Example: **$5 + 6 = 11$**
* But in 4 bits, max is **$+7$**, so the result wraps around to **$-3$**

### ğŸ“Œ Negative Overflow:

* Example: **$-5 - 7 = -12$**
* But min is **$-7$**, so it wraps to **$+6$**

### âœ… Why?

* The representation is like a **circular ring** â€” if you exceed the limit, the number â€œwrapsâ€ around from one side to the other.

@import "Negative overflow.png" 

@import "Positive overflow.png"

---

## âœ… Applications:

* **Not used** for storing regular integers due to:

  * Duplicate zero values
  * Complicated arithmetic
* **Used in**:

  * Floating-point number representation (for the **sign bit**)
  * **Analog-to-digital conversion**, like **audio encoding**

---

## âœ… 3.2.3 Storing Reals


### ğŸ“Œ Problem with Fixed-Point Representation

* **Fixed-point** uses a fixed number of digits for the integral and fractional parts.
* Can **lose precision or accuracy** depending on number scale.

#### Example 3.16 â€“ Loss of Precision

Fixed-point with 14 digits left, 2 digits right:

* **Storing $1.00234$ â†’ becomes $1.00$ (fraction lost)**

#### Example 3.17 â€“ Loss of Accuracy

Fixed-point with 10 digits left, 6 right:

* **Storing $236154302345.00$ â†’ becomes $6154302345.00$ (integer part truncated)**

---

### âœ… Floating-Point Representation


>**Allows the decimal point to **â€œfloatâ€**â€”supports wide range of values.**

#### Structure (3 parts)

1. **Sign**: + or -
2. **Exponent (shifter)**: how many positions the decimal moves
3. **Mantissa (fixed-point part)**: normalized real number

#### Scientific Notation 


**$+7425000000000000000000.00 â†’ $ $+7.425 \times 10^{21}$ â†’ 7.425E21**


#### Example 3.19


**$-0.0000000000000232 â†’ $ $ -2.32 \times 10^{-14} $ â†’ -2.32E-14**


---

### âœ… Floating-Point in Binary

#### Example 3.20


**$(101001000000000000000000000000000.00)_2 \rightarrow 1.01001 \times 2^{32}$**



#### Example 3.21

**$(0.00000000000000000000000101)_2 \rightarrow 1.01 \times 2^{-24}$**

---

### âœ… Normalization

Make the representation **standard**:

* **Decimal:** `Â±d.xxxxx` (where d = 1â€“9)
* **Binary:** `Â±1.yyyyy` (only one 1 before the decimal)

---

## âœ… The Excess System (Biased Representation)

### âœ… How Floating-Point Numbers Are Stored

**A floating-point number is typically stored using two main components:**

| Component    | Description                                                                                                                                           |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Mantissa** | The significant digits, stored as **unsigned integer**                                                                                                |
| **Exponent** | Indicates how far to shift the decimal point (base 2), stored as a **signed number**, but using **Excess representation** instead of two's complement |

---

### âœ… What Is the **Excess System**?

**Goal**: To store signed exponents using **only positive (unsigned) integers** for easier processing.

#### â­ How It Works:

* We **add a fixed bias to shift the entire range into non-negative values.**



**Bias = $2^{m - 1} - 1$**




Where **$m$** is the number of bits allocated to the exponent.

---

### âœ… Example 3.22: 4-Bit Exponent (Excess-7)

With 4 bits, we can represent 16 values (0 to 15). To represent signed values from **â€“7 to +8**, we use a **bias of 7**:

**$ Bias = 2^{4 - 1} - 1 = 8 - 1 = 7 $**


| Actual Exponent | Stored Value (Excess-7) |
| --------------- | ----------------------- |
| â€“7              | 0                       |
| â€“6              | 1                       |
| â€“5              | 2                       |
| ...             | ...                     |
| 0               | 7                       |
| 1               | 8                       |
| ...             | ...                     |
| 8               | 15                      |

---

## ğŸŒ IEEE Floating-Point Standards

The **IEEE (Institute of Electrical and Electronics Engineers)** defines standard formats for floating-point representation:

| Format           | Total Bits | Sign Bit | Exponent Bits | Mantissa Bits | Bias |
| ---------------- | ---------- | -------- | ------------- | ------------- | ---- |
| Single Precision | 32         | 1        | 8             | 23            | 127  |
| Double Precision | 64         | 1        | 11            | 52            | 1023 |

> Both use the **Excess system** for exponent storage.

---

### Format Overview

| **Component**    | **Bits** | **Description**                                                     |
| ---------------- | -------- | ------------------------------------------------------------------- |
| **S (Sign bit)** | 1        | `0` for positive, `1` for negative                                  |
| **E (Exponent)** | 8        | Stored using **Excess-127** (bias = 127)                            |
| **M (Mantissa)** | 23       | Fractional part after normalization (implicit leading 1 not stored) |

---

### âœ… **Storing a Decimal Number (Encoding)**

**Steps:**

1. Determine the **sign bit (S)**: â†’ `0` if positive, `1` if negative
2. Convert the number to **binary**.
3. Normalize to the form:
   â†’ $1.xxx \times 2^e$
4. Compute **E**:
   â†’ $E = e + 127$
5. Extract **mantissa M**:
   â†’ Use the **fractional part only** (after removing the leading $1.$), pad with zeros to **$23$** bits.
6. Concatenate:
  **$$ â†’ S + 8-bit E + 23-bit M $$**

---

### ğŸ” **Retrieving a Decimal Number (Decoding)**

**Steps:**

1. Extract **S, E, M** from the 32-bit binary pattern.
2. Determine **sign**:
   â†’ `+` if S = 0, `â€“` if S = 1
3. Compute **exponent e**:
   â†’ $e = E - 127$
4. Restore mantissa:
   â†’ Add the implicit `1.` before the mantissa bits.
5. Multiply:
   â†’ $\text{value} = \pm(1.M) \times 2^e$

---

### âœï¸ Example: Store 5.75 in IEEE 754 Format

**Step-by-step:**

* a. Sign is positive â†’ `S = 0`
* b. Decimal to binary:
  $5.75 = (101.11)_2$
* c. Normalize:
  $(101.11)_2 = (1.0111)_2 \times 2^2$
* d. Compute exponent:
  $E = 2 + 127 = 129 = (10000001)_2$
* e. Mantissa M = `01110000000000000000000` (pad to 23 bits)

**Result:**

```
S     E              M
0 10000001 01110000000000000000000
```

**Stored as binary:**
**$01000000101110000000000000000000$**


---

## âœ… Twoâ€™s Complement Representation 

### ğŸ§  Core Concept

* **Twoâ€™s complement** is the most common method used by computers to store **signed integers**.
* In an **n-bit system**, the range **$[0, 2â¿ - 1]$** is divided into:

  * One half for **non-negative integers** (including 0),
  * One half for **negative integers**.

> Example (n = 4 bits):
> Binary range: **$0000$** to **$1111$**
> Non-negative: **$0000$** to **$0111$** (**$0$** to **$+7$**)
> Negative: **$1000$** to **$1111$** (**$âˆ’8$** to **$âˆ’1$**)

---

### ğŸ§¾ Sign Determination

* The **leftmost bit (MSB)** is the **sign bit**:

  * **$0 â†’ non-negative$**
  * **$1 â†’ negative$**

---

### ğŸ”„ Oneâ€™s Complement

* **Definition: Flip every bit (0 becomes 1, 1 becomes 0)**

#### âœ… Example 3.8


**Original:**        **$$00110110$$**  
**Oneâ€™s complement:** **$$11001001$$**


#### âœ… Example 3.9

Oneâ€™s complement is **reversible** if applied twice:


**Original: $$00110110$$**  
**â†’ Oneâ€™s comp: $$11001001$$**  
**â†’ Again:      $$00110110$$**


---

### ğŸ” Twoâ€™s Complement

>#### Method 1: Copy from right to left up to the first **$1$** (inclusive), then flip the remaining bits.

âœ… **Example 3.10**


**Original:        $$00110100$$**  
**Twoâ€™s complement: $$11001100$$**


#### Method 2: Oneâ€™s complement + Add 1

* **Formula** **$$ \text{Two's complement}(x) = \sim x + 1 $$**


âœ… **Example 3.11** (Double twoâ€™s complement returns original):

**$$\begin{array}{rl}\text{Original:} & \quad 00110100 \\\Rightarrow \text{Twoâ€™s complement:} & \quad 11001100 \\\Rightarrow \text{Again:} & \quad 00110100 \\\end{array}
$$**


---

### ğŸ’¾ Storing a Signed Integer

To store a signed integer:

1. Get its **absolute binary** value.
2. **If the number is non-negative â†’ store as-is.**
3. If it is negative â†’ **take the twoâ€™s complement** and store it.

---

### ğŸ” Retrieving a Signed Integer

To read a stored twoâ€™s complement value:

1. If the **MSB is 1**, apply twoâ€™s complement â†’ result is **negative**.
2. If the **MSB is 0**, read as-is â†’ result is **non-negative**.


---



