
## **3.2.1 Storing Integers**

### ‚úÖ What is an Integer?

An **integer** is a whole number ‚Äî it has **no decimal or fraction**.
Examples:

*  `134`, `-125` are integers
*  `134.23`, `-0.235` are **not** integers

To store integers, computers use a method called **fixed-point representation**.

> üìå This means the **decimal point is fixed** (assumed to be at the right) and **not actually stored**.

---

### ‚úÖ **Unsigned Integers**

An **unsigned integer** is a number that can only be **0 or positive**.
It **cannot** be negative.

#### üìå Memory Limitation

If a computer uses **n bits**, the maximum unsigned integer is:

> **$2^n -1 $**

Example:

 **$$\text{if} \ n = 4 \rightarrow \text{max number} = 2^4 ‚àí 1 = 15$$**

---

### ‚úÖ What is Overflow?

**Overflow** happens when a number is **too big** to fit in the available bits.

#### Example:

If you try to store the number **20** in **4 bits**:

* 20 in binary = `10100` (needs 5 bits!)
* If only 4 bits are allowed, computer keeps last 4 bits ‚Üí `0100`
* `0100` in decimal = **4** 

---

### ‚úÖ Why Use Unsigned Integers?

Because:

* You don‚Äôt need to store the sign **(no negative numbers)**
* You can use **all bits** for the number ‚Üí **more efficient**

#### Example Uses:

* **Counting** (e.g., number of people)
* **Memory addresses** (locations are never negative)
* **Storing data** like images, audio, and text ‚Äî just patterns of bits

---

### ‚úÖ How to Store Unsigned Integers (Steps)

1. Convert the integer to **binary**
2. If it needs **fewer than n bits**, add `0`s on the **left**
3. If it needs **more than n bits**, it **can‚Äôt be stored** ‚Äî this is **overflow**

#### Example 3.1: Store 7 in 8 bits

* 7 in binary = `111`
* Add 5 zeros ‚Üí `00000111`

#### Example 3.2: Store 258 in 16 bits

* 258 in binary = `100000010`
* Add 7 zeros ‚Üí `0000000100000010`

---

### ‚úÖ Retrieving Unsigned Integers

To **get a number back** from memory:

* The output device reads the **bit string**
* Then **converts it** to a decimal number

#### Example 3.3:

Bit string in memory = `00101011`

* Convert to decimal = **43**

---

## ‚úÖ Sign-and-Magnitude Representation

### üìå What is it?

Sign-and-magnitude is a way to store integers where:

* The **leftmost bit** represents the **sign**:

  * `0` for positive
  * `1` for negative
* The **remaining bits** store the **magnitude** (i.e., the absolute value).

---

### ‚úÖ Key Characteristics:

* For an **$n-bit$** value, the **range** is:

  **$$
  -(2^{n-1} - 1) \text{ to } + (2^{n-1} - 1)
  $$**
* There are **two zeros**: positive zero (e.g. `0000`) and negative zero (e.g. `1000`)
* It‚Äôs **not commonly used** for integers, but it **is used**:

  * To store the **sign** part of **floating-point numbers**
  * In **analog signal quantization**, such as **audio**

---

### üìå Examples:

#### üßæ Example 3.4: Store `+28` in 8-bit memory

1. Convert **$28$** to 7-bit binary ‚Üí **$0011100$**
2. Add sign bit **$0$** at the front ‚Üí **$00011100$**

#### üßæ Example 3.5: Store `-28` in 8-bit memory

1. Binary of **$28 ‚Üí 0011100$**
2. Add sign bit **$1 \rightarrow 10011100 $**

#### üßæ Example 3.6: Interpret `01001101`

* Leftmost bit = **$0 ‚Üí positive$**
* Remaining bits **$1001101 = 77$**
* So, the number is **$+77$**

#### üßæ Example 3.7: Interpret `10100001`

* Leftmost bit = **$1 ‚Üí negative$**
* Remaining bits **$0100001 =33$**
* So, the number is =**$\space -33$**

---

## ‚úÖ Overflow in Sign-and-Magnitude

### üìå Positive Overflow:

* Example: **$5 + 6 = 11$**
* But in 4 bits, max is **$+7$**, so the result wraps around to **$-3$**

### üìå Negative Overflow:

* Example: **$-5 - 7 = -12$**
* But min is **$-7$**, so it wraps to **$+6$**

### ‚úÖ Why?

* The representation is like a **circular ring** ‚Äî if you exceed the limit, the number ‚Äúwraps‚Äù around from one side to the other.

@import "Negative overflow.png" 

@import "Positive overflow.png"

---

## ‚úÖ Applications:

* **Not used** for storing regular integers due to:

  * Duplicate zero values
  * Complicated arithmetic
* **Used in**:

  * Floating-point number representation (for the **sign bit**)
  * **Analog-to-digital conversion**, like **audio encoding**

---

## ‚úÖ 3.2.3 Storing Reals


### üìå Problem with Fixed-Point Representation

* **Fixed-point** uses a fixed number of digits for the integral and fractional parts.
* Can **lose precision or accuracy** depending on number scale.

#### Example 3.16 ‚Äì Loss of Precision

Fixed-point with 14 digits left, 2 digits right:

* **Storing $1.00234$ ‚Üí becomes $1.00$ (fraction lost)**

#### Example 3.17 ‚Äì Loss of Accuracy

Fixed-point with 10 digits left, 6 right:

* **Storing $236154302345.00$ ‚Üí becomes $6154302345.00$ (integer part truncated)**

---

### ‚úÖ Floating-Point Representation


>**Allows the decimal point to **‚Äúfloat‚Äù**‚Äîsupports wide range of values.**

#### Structure (3 parts)

1. **Sign**: + or -
2. **Exponent (shifter)**: how many positions the decimal moves
3. **Mantissa (fixed-point part)**: normalized real number

#### Scientific Notation 


**$+7425000000000000000000.00 ‚Üí $ $+7.425 \times 10^{21}$ ‚Üí 7.425E21**


#### Example 3.19


**$-0.0000000000000232 ‚Üí $ $ -2.32 \times 10^{-14} $ ‚Üí -2.32E-14**


---

### ‚úÖ Floating-Point in Binary

#### Example 3.20


**$(101001000000000000000000000000000.00)_2 \rightarrow 1.01001 \times 2^{32}$**



#### Example 3.21

**$(0.00000000000000000000000101)_2 \rightarrow 1.01 \times 2^{-24}$**

---

### ‚úÖ Normalization

Make the representation **standard**:

* **Decimal:** `¬±d.xxxxx` (where d = 1‚Äì9)
* **Binary:** `¬±1.yyyyy` (only one 1 before the decimal)

---

## ‚úÖ The Excess System (Biased Representation)

### ‚úÖ How Floating-Point Numbers Are Stored

**A floating-point number is typically stored using two main components:**

| Component    | Description                                                                                                                                           |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Mantissa** | The significant digits, stored as **unsigned integer**                                                                                                |
| **Exponent** | Indicates how far to shift the decimal point (base 2), stored as a **signed number**, but using **Excess representation** instead of two's complement |

---

### ‚úÖ What Is the **Excess System**?

**Goal**: To store signed exponents using **only positive (unsigned) integers** for easier processing.

#### ‚≠ê How It Works:

* We **add a fixed bias to shift the entire range into non-negative values.**



**Bias = $2^{m - 1} - 1$**




Where **$m$** is the number of bits allocated to the exponent.

---

### ‚úÖ Example 3.22: 4-Bit Exponent (Excess-7)

With 4 bits, we can represent 16 values (0 to 15). To represent signed values from **‚Äì7 to +8**, we use a **bias of 7**:

**$ Bias = 2^{4 - 1} - 1 = 8 - 1 = 7 $**


| Actual Exponent | Stored Value (Excess-7) |
| --------------- | ----------------------- |
| ‚Äì7              | 0                       |
| ‚Äì6              | 1                       |
| ‚Äì5              | 2                       |
| ...             | ...                     |
| 0               | 7                       |
| 1               | 8                       |
| ...             | ...                     |
| 8               | 15                      |

---

## üåê IEEE Floating-Point Standards

The **IEEE (Institute of Electrical and Electronics Engineers)** defines standard formats for floating-point representation:

| Format           | Total Bits | Sign Bit | Exponent Bits | Mantissa Bits | Bias |
| ---------------- | ---------- | -------- | ------------- | ------------- | ---- |
| Single Precision | 32         | 1        | 8             | 23            | 127  |
| Double Precision | 64         | 1        | 11            | 52            | 1023 |

> Both use the **Excess system** for exponent storage.

---

### Format Overview

| **Component**    | **Bits** | **Description**                                                     |
| ---------------- | -------- | ------------------------------------------------------------------- |
| **S (Sign bit)** | 1        | `0` for positive, `1` for negative                                  |
| **E (Exponent)** | 8        | Stored using **Excess-127** (bias = 127)                            |
| **M (Mantissa)** | 23       | Fractional part after normalization (implicit leading 1 not stored) |

---

### ‚úÖ **Storing a Decimal Number (Encoding)**

**Steps:**

1. Determine the **sign bit (S)**: ‚Üí `0` if positive, `1` if negative
2. Convert the number to **binary**.
3. Normalize to the form:
   ‚Üí $1.xxx \times 2^e$
4. Compute **E**:
   ‚Üí $E = e + 127$
5. Extract **mantissa M**:
   ‚Üí Use the **fractional part only** (after removing the leading $1.$), pad with zeros to **$23$** bits.
6. Concatenate:
  **$$ ‚Üí S + 8-bit E + 23-bit M $$**

---

### üîÅ **Retrieving a Decimal Number (Decoding)**

**Steps:**

1. Extract **S, E, M** from the 32-bit binary pattern.
2. Determine **sign**:
   ‚Üí `+` if S = 0, `‚Äì` if S = 1
3. Compute **exponent e**:
   ‚Üí $e = E - 127$
4. Restore mantissa:
   ‚Üí Add the implicit `1.` before the mantissa bits.
5. Multiply:
   ‚Üí $\text{value} = \pm(1.M) \times 2^e$

---

### ‚úèÔ∏è Example: Store 5.75 in IEEE 754 Format

**Step-by-step:**

* a. Sign is positive ‚Üí `S = 0`
* b. Decimal to binary:
  $5.75 = (101.11)_2$
* c. Normalize:
  $(101.11)_2 = (1.0111)_2 \times 2^2$
* d. Compute exponent:
  $E = 2 + 127 = 129 = (10000001)_2$
* e. Mantissa M = `01110000000000000000000` (pad to 23 bits)

**Result:**

```
S     E              M
0 10000001 01110000000000000000000
```

**Stored as binary:**
**$01000000101110000000000000000000$**

---


