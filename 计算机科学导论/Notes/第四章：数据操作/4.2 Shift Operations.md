
## âœ… 4.2 SHIFT OPERATIONS

**Shift operations** move the bits in a pattern **left** or **right**.

**There are two main types:**

* **Logical Shift**: Used for **unsigned data**
* **Arithmetic Shift**: Used for **signed data** (discussed later)

---

## âœ… 4.2.1 Logical Shift Operations



### ğŸ’¡ What is a Logical Left Shift?

A **logical left shift** moves every bit in the pattern one position to the **left**, and fills the **rightmost** bit with a **$0$**. The **leftmost** bit is **lost**.

Example:
Original (8 bits): **$$10011000$$**
Left shift : **$$00110000$$**

---


## âœ… Circular Shift 

Unlike **logical shift**, a **circular shift** (or rotate) operation **does not lose any bits**.

### ğŸ“Œ Circular Right Shift:

* Each bit moves one position **to the right**.
* The **rightmost** bit wraps around and becomes the **leftmost** bit.

### ğŸ“Œ Circular Left Shift:

* Each bit moves one position **to the left**.
* The **leftmost** bit wraps around and becomes the **rightmost** bit.

---

### âœ… Example 4.11: Circular Left Shift

**Original pattern:**


**$$1 \  0\ 0\ 1\ 1\ 0\ 0\ 0$$**

**After circular left shift:**


**$$0\ 0\ 1\ 1\ 0\ 0\ 0\ 1$$**


ğŸ” Explanation:

* Leftmost bit **$1$** becomes the new **rightmost**.
* All other bits shift one place **to the left**.

---

## ğŸ“Œ Example 4.12: Bit Testing with Logical Shift and AND

### Problem:

You want to **check the 3rd bit from the right** 

### ğŸ› ï¸ Steps:

Letâ€™s say your 8-bit pattern is:


**$$1\ 0\ 1\ 1\ 0\ 0\ 1\ 0$$**


#### Step 1: Shift right by 2


**$$1\ 0\ 1\ 1\ 0\ 0\ 1\ 0\  â†’\  0\ 0\ 1\ 0\ 1\ 1\ 0\ 0$$**


The **target bit** (3rd from right) now becomes the **rightmost** bit.

#### Step 2: AND with mask **$0\ 0\ 0\ 0\ 0\ 0\ 0\ 1$**


**$$
\begin{array}{cccccccc}
0 & 0 & 1 & 0 & 1 & 1 & 0 & 0 \\
\text{AND} \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\end{array}
$$**



* Result is **$0\ 0\ 0\ 0\ 0\ 0\ 0\ x$** where **$x$** is **$1$** if the bit was **$1$**, or **$0$** if it was **$0$**.

#### Step 3: Check the result:

* If the final value is **$1$**, then the original bit was **$1$**.
* If the final value is **$0$**, then the original bit was **$0$**.

---


## ğŸ” Arithmetic Shift Operations 

### ğŸ§  Core Idea

* Applied to **signed integers** stored in **twoâ€™s complement** format.
* Used for **multiplying/dividing** integers by **2**.
* Special care is taken to **preserve the sign bit** (leftmost bit).

---

### ğŸ”½ Arithmetic Right Shift (Ã·2)

* **Purpose**: Divide a signed number by 2 (rounding toward 0).
* **Mechanism**:

  * **Leftmost sign bit is preserved**.
  * The sign bit is **copied** into the next bit.
  * The rightmost bit is **discarded**.

âœ… **Effect**: Preserves negative/positive sign.

#### Example 4.13


Original:      **$10011001$**  **$(â€“103)$**
After shift:   **$11001100$**  **$(â€“52)$**


---

### ğŸ”¼ Arithmetic Left Shift (Ã—2)

* **Purpose**: Multiply a signed number by 2.
* **Mechanism**:

  * Leftmost bit is **lost**.
  * Rightmost bit is filled with 0.
  * New leftmost bit becomes the new sign.

âš ï¸ Must check for **overflow** (i.e., when the sign flips unexpectedly).

#### Example 4.14 â€“ Valid

```
Original:      11011001 (â€“39)
After shift:   10110010 (â€“78)
```

#### Example 4.15 â€“ Invalid (overflow)

```
Original:      01111111 (+127)
After shift:   11111110 (â€“2) âŒ overflow
```

â†’ Expected result `127 Ã— 2 = 254` cannot fit in 8 bits.

---
